#!/usr/bin/env python3

import re
import sys
import json
import shlex
import logging
import argparse
import traceback

logger = logging.getLogger(__name__)


def _get_file_io(name, write=False):
    if name == '-' and write:
        return sys.stdout
    elif name == '-' and not write:
        return sys.stdin
    else:
        return open(name, 'w' if write else 'r')

def stream(source, target, transform_py=None, filter_py=None, expression=True, flush=False, show_exceptions=False, force_blank=False):
    transform_runner = eval if expression else exec
    filter_code = None
    transform_code = None
    try:
        if transform_py:
           transform_code = compile(transform_py, '<string::transform>', transform_runner.__name__)
        if filter_py:
            filter_code = compile(filter_py, '<string::filter>', 'eval')
    except Exception as e:
        logger.exception('Error parsing command:')
        sys.exit(1)

    for i, line in enumerate(source):
        line = line.rstrip('\n')
        scope = {'line': line, 'i': i, 'index': i}

        if filter_code:
            try:
                keep = eval(filter_code, globals(), scope)
            except Exception as e:
                keep = False
                if show_exceptions:
                    traceback.print_exc()
            if not keep:
                continue

        if transform_code:
            try:
                if expression:
                    line = transform_runner(transform_code, globals(), scope)
                else:
                    transform_runner(transform_code, globals(), scope)
                    line = scope.get('result', None) or scope.get('line', None) or line
            except Exception as e:
                if show_exceptions:
                    traceback.print_exc()
                if force_blank:
                    line = ''
                else:
                    continue

        target.write(str(line) + '\n')
        if flush and hasattr(target, 'flush'):
            target.flush()

def stream_command():
    cmd_parser = argparse.ArgumentParser(prog='Python line stream manipulation. Executed code has access to "line" value')
    cmd_parser.add_argument(
        'command',
        nargs='?',
        help='Python expression (or statements if --exec) to be evaluated to transform each line'
    )
    cmd_parser.add_argument(
        '-f', '--filter',
        help='Only output line if given expression evaluates to something truthy',
        default=None,
    )
    cmd_parser.add_argument(
        '-s', '--statements',
        action='store_true',
        help='Enable full python statements instead of just expressions (Assign to "result" or "line")',
        default=False,
    )
    cmd_parser.add_argument(
        '-b', '--allow-buffer',
        help='Dont force every line to be flushed',
        default=False,
    )
    cmd_parser.add_argument(
        '-i', '--input',
        help='Set source for tranformations (Default stdin)',
        default='-',
    )
    cmd_parser.add_argument(
        '-o', '--output',
        help='Set target for tranformations output (Default stdout)',
        default='-',
    )
    cmd_parser.add_argument(
        '-x', '--show-exceptions',
        action='store_true',
        help='Show exceptions',
        default=False,
    )
    cmd_parser.add_argument(
        '-l', '--use-blanks',
        action='store_true',
        help='Default to a blank line for exceptions',
        default=False,
    )
    args = cmd_parser.parse_args()

    source = _get_file_io(args.input)
    target = _get_file_io(args.output, write=True)

    try:
        stream(
            source,
            target,
            transform_py=args.command,
            filter_py=args.filter,
            flush=not args.allow_buffer,
            expression=not args.statements,
            show_exceptions=args.show_exceptions,
            force_blank=args.use_blanks,
        )
    except (KeyboardInterrupt, Exception) as e:
        if not isinstance(e, KeyboardInterrupt):
            logging.exception('Stream io failed:')
    finally:
        if hasattr(source, 'close'):
            source.close()
        if hasattr(target, 'close'):
            target.close()


if __name__ == '__main__':
    stream_command()
